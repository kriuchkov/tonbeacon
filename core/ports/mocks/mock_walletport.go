// Code generated by mockery v2.52.3. DO NOT EDIT.

package portsmocks

import (
	context "context"

	model "github.com/kriuchkov/tonbeacon/core/model"
	mock "github.com/stretchr/testify/mock"
)

// MockWalletPort is an autogenerated mock type for the WalletPort type
type MockWalletPort struct {
	mock.Mock
}

type MockWalletPort_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWalletPort) EXPECT() *MockWalletPort_Expecter {
	return &MockWalletPort_Expecter{mock: &_m.Mock}
}

// CreateWallet provides a mock function with given fields: ctx, walletID
func (_m *MockWalletPort) CreateWallet(ctx context.Context, walletID uint32) (model.WalletWrapper, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for CreateWallet")
	}

	var r0 model.WalletWrapper
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (model.WalletWrapper, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) model.WalletWrapper); ok {
		r0 = rf(ctx, walletID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.WalletWrapper)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletPort_CreateWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWallet'
type MockWalletPort_CreateWallet_Call struct {
	*mock.Call
}

// CreateWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID uint32
func (_e *MockWalletPort_Expecter) CreateWallet(ctx interface{}, walletID interface{}) *MockWalletPort_CreateWallet_Call {
	return &MockWalletPort_CreateWallet_Call{Call: _e.mock.On("CreateWallet", ctx, walletID)}
}

func (_c *MockWalletPort_CreateWallet_Call) Run(run func(ctx context.Context, walletID uint32)) *MockWalletPort_CreateWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32))
	})
	return _c
}

func (_c *MockWalletPort_CreateWallet_Call) Return(_a0 model.WalletWrapper, _a1 error) *MockWalletPort_CreateWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletPort_CreateWallet_Call) RunAndReturn(run func(context.Context, uint32) (model.WalletWrapper, error)) *MockWalletPort_CreateWallet_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function with given fields: ctx, walletID
func (_m *MockWalletPort) GetBalance(ctx context.Context, walletID uint32) (uint64, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (uint64, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) uint64); ok {
		r0 = rf(ctx, walletID)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletPort_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type MockWalletPort_GetBalance_Call struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID uint32
func (_e *MockWalletPort_Expecter) GetBalance(ctx interface{}, walletID interface{}) *MockWalletPort_GetBalance_Call {
	return &MockWalletPort_GetBalance_Call{Call: _e.mock.On("GetBalance", ctx, walletID)}
}

func (_c *MockWalletPort_GetBalance_Call) Run(run func(ctx context.Context, walletID uint32)) *MockWalletPort_GetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32))
	})
	return _c
}

func (_c *MockWalletPort_GetBalance_Call) Return(_a0 uint64, _a1 error) *MockWalletPort_GetBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletPort_GetBalance_Call) RunAndReturn(run func(context.Context, uint32) (uint64, error)) *MockWalletPort_GetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetExtraCurrenciesBalance provides a mock function with given fields: ctx, walletID
func (_m *MockWalletPort) GetExtraCurrenciesBalance(ctx context.Context, walletID uint32) ([]model.Balance, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for GetExtraCurrenciesBalance")
	}

	var r0 []model.Balance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) ([]model.Balance, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) []model.Balance); ok {
		r0 = rf(ctx, walletID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Balance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletPort_GetExtraCurrenciesBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExtraCurrenciesBalance'
type MockWalletPort_GetExtraCurrenciesBalance_Call struct {
	*mock.Call
}

// GetExtraCurrenciesBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID uint32
func (_e *MockWalletPort_Expecter) GetExtraCurrenciesBalance(ctx interface{}, walletID interface{}) *MockWalletPort_GetExtraCurrenciesBalance_Call {
	return &MockWalletPort_GetExtraCurrenciesBalance_Call{Call: _e.mock.On("GetExtraCurrenciesBalance", ctx, walletID)}
}

func (_c *MockWalletPort_GetExtraCurrenciesBalance_Call) Run(run func(ctx context.Context, walletID uint32)) *MockWalletPort_GetExtraCurrenciesBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32))
	})
	return _c
}

func (_c *MockWalletPort_GetExtraCurrenciesBalance_Call) Return(_a0 []model.Balance, _a1 error) *MockWalletPort_GetExtraCurrenciesBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletPort_GetExtraCurrenciesBalance_Call) RunAndReturn(run func(context.Context, uint32) ([]model.Balance, error)) *MockWalletPort_GetExtraCurrenciesBalance_Call {
	_c.Call.Return(run)
	return _c
}

// MasterWallet provides a mock function with given fields: ctx
func (_m *MockWalletPort) MasterWallet(ctx context.Context) (model.WalletWrapper, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MasterWallet")
	}

	var r0 model.WalletWrapper
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (model.WalletWrapper, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) model.WalletWrapper); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(model.WalletWrapper)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletPort_MasterWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MasterWallet'
type MockWalletPort_MasterWallet_Call struct {
	*mock.Call
}

// MasterWallet is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockWalletPort_Expecter) MasterWallet(ctx interface{}) *MockWalletPort_MasterWallet_Call {
	return &MockWalletPort_MasterWallet_Call{Call: _e.mock.On("MasterWallet", ctx)}
}

func (_c *MockWalletPort_MasterWallet_Call) Run(run func(ctx context.Context)) *MockWalletPort_MasterWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockWalletPort_MasterWallet_Call) Return(_a0 model.WalletWrapper, _a1 error) *MockWalletPort_MasterWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletPort_MasterWallet_Call) RunAndReturn(run func(context.Context) (model.WalletWrapper, error)) *MockWalletPort_MasterWallet_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWalletPort creates a new instance of MockWalletPort. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWalletPort(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWalletPort {
	mock := &MockWalletPort{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
